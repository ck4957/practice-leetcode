Paychex: Threads(Lifecycle), Collections, Serializable,For scenario, which data structure is feasible-JVM :its a runtime environment for the compiled java class files-JDK is for development purpose and it includes execution environment also.-Java doesnt support multiple inheritance.-JAva uses primitive data type and hence its not a pure object oriented language-Pointers is reference handle to a memory location. Improper handling of pointers leads to memory leaks and reliability issues.-In Java, Arrays are objects and not primitive data type.-Path and Classpath are operating system level environment variables. Path is used to define where the system can find the executable files and classpath is used to specify the location of .class files.-Local variables are those which are defined within blocks of code like methods. Variables needs to be initialized before using them-To define a constant variable in java, it needs to be declared as static and final so only one copy of variable exists for all the instances. ex: static final int PI=3.14;-Main method is not required for all java classes and should be defined only if soource class is a java application-Main method is called by JVM even before the instantiation of the class hence declared static-Main method can be overloaded with different method signature and implementation-Order of public and static delaration in main() method doesnt matter.-A single source file can have any number of class declarations but only one of them should be declared as public.-Package is collection of classes and interface ahd should be the first statement in a java class.-java.lang package is imported by default even if it is not declared.-Class declared a private cannot be accessed outside its package.- A class cant be declared as protected only method can be declared as protected.- A method declared as final cant be overridden. A sub-class cant have the same method signature with a different implementation.- A class declared as final cannot be extended/inherited  by any other class. Abstract class cannot be defined as final. Ex: java.lang.String, java.lang.Math are final classesFinal : its a modifier which can be applied to a class or method or a variable. Final class cant be inherited, final method cant be overridden, and final variable cant be changed.finally: its an exception handling code section which gets executed whether an exception is raised or not by the try code block segment.finalize(): is a method of the object class which will be executed by JVM just before garbage collecting object to give a final chance for resource releasing activity-Top level class cannot be declared as static but only inner class can be declared as staticQ: JAva Serialization?-Java provides a mechanism, called object serialization where object can be represented as a sequence of bytes that includes the object's data as well as information about the object's type and the types of data stored  in the object.-Purpose is to write an object into a stream, so that it can be transported through a network and that object can be rebuilt again.-Classes ObjectInputStream and ObjectOutputStream are high-level stream that contain method for serializing and deserializing the object.Transient : skip the serialization process.Variable declared as transient will not be serialized and when we deserializle an object that variable will get some default valueQ == and equals() method- == compares the reference value of the object. s1 = "Are" (2314) s2 = "Are"(2314) --> (2314) == (2314)- Equals compares the content of the object.s1 = "Are" (2314) s2 = "Are"(2314) --> "Are" == "Are"Q: What are OOPL advantages?-OOPL directly represent the real life objects like Employee, Acoount, Car, customer Etc-Features like Polymorphism, inheritence, Encapsulation makes it powerful-Reuse of previous work-Real mapping to the problem domainQ: Diff between Java & c++Java doesnt support pointers(tricky to use and troublesome),desctructors,multiple inheritances(instead support multiple interface inheritance), structures or unions(bcoz tradition data structure are implemented as object oriented framework)C++ rewuires explicit mgmt, while java includes garbage collectionAll code in java is encapsulated so it dont have global variablesQ: Java platform independent?[Write once and run everywhere]-Java code that you write gets converted to bytecode that is present in .class files.Every OS(Windows, Unix ,Linux)  has its own JVM.-JVM takes the bytecode and then executes the program. So h/w dependency is taken care of by JVM.- C++ program have to be recompiled for it to run on different OS. Thus Platform dependent.JVM: is a s/w that is ported onto various H/w platforms. Bytecode are machine language of the JVM.Java API : set of classes written using java language and run on the JVMQ Java Bytecode?its a form of instructions that JVM executes.Q Why public static void main?public : main method is called by JVM to run the method which is outside the project therefore the access specifier has to be public to permit call anywhere outside the applicationStatic: When the JVM calls the method there is no object existing for the class being called, therefore it has to static method to allow invocation from class.void: We are trying to return a value to OS which might be different for different OS, so just void it. Q: Difference Abstract Class and InterfacesAbstract Class:- Abstract class cannot be instantiated.(We cannot create object of abstract class)- Some methods have implementation code. while abstract methods will not have implementation- Abstract class can have fields( variable declaration are allowed)- Have executable methods and abstract methods. Can only subclass one abstract class.- Doesn't support multiple class inheritence. Eg: Migration.java    public boolean copyFiles(){} --> Used by both import and export (No Duplication)    public abstract void migrate(); --> Different implementation by Export and Import class    Export.java                             Import.java    public void migrate()                   public void migrate()    {                                       {        Export way of implementation            Import way of implementation    }                                       }Interface:A Class can implement any number of interfaces. Have no implementation code at all..It only contains declarations. All methods are abstract.- Interface cannot have fields- Iterface can inherit multiple interfacesEx: File.java(Interface) : public void fileOpen();    All there classes have its own implementation of fileOpen method    PDFFile.java: public void fileOpen(){...};    XLSFile.java: public void fileOpen(){...};    PPTFile.java: public void fileOpen(){...};Q:What is use of Garbage Collector?A: For every object created in Java, it goes into Heap memory. The Java Heap is called the Garbage Collectable heap. Garbage collection cannot be forced. IT runs on low priority daemon thread. When it runs, it releases the memory allocated by unreachable object.We can request garbage collector to collect garbage by calling  System.gc() but cant force it.Ex:Car a = new Car(); --(1)Car b = new Car(); --(2)a = new Car();--> Reachable Object, however (1) becomes unreachableThreadsJava programs, applications, and applets can consists of threads which conceptually are executed inparallel. This section demonstrates with simple examples how threads are created and manipulated,how exclusive access to common variables is managed, how conditional access is obtained, and howthreads are connected with pipelines. Two classical examples concern communication with semaphoresand conditional access to resources.THread States: Thread t = new Thread();New(Thread is not alive yet) : t = new Thread(); Ready/Runnable(Thread starts itd life): t.start()Run(scheduler selects a thread from thread pool): t.run(){}Dead(when run method is completed. It can never run again): run{...} completedWait(wait for specified amount of time): t.wait(); Blocked(because thread is waiting for the resources that are hold by another thread)Q: Difference between Java thread and Deamon thread?JVM exists an application when all the user threads are complete.JVM doesnt care about letting daemon threads to complete, so once all the user threads are complete, JVM will shutdown, regardless of the state of the daemon threads.Q: calling start method twice?It is never legal to start a thread more than once, a thread may not be restarted once its has completed execution. If a thread needs to be run more than once, then one should make a new instance of the thread.Throws a IllegalThreadStateExceptionQ: can i call run() method using thread object?Yes. but JVM will not consider it as a thread execution rather it is a normal method call.Principles and Features• A thread is a thread of execution in a program. The Java Virtual Machine allows an applicationto have multiple threads of execution running concurrently.• Every thread has a priority. Threads with higher priority are executed in preference to threadswith lower priority.• Each thread may or may not also be marked as a daemon. The Java Virtual Machine exitswhen the only threads running are daemon threads.• When code running in some thread creates a new Thread object, the new thread has its priorityinitially set equal to the priority of the creating thread, and is a daemon thread if and only if thecreating thread is a daemon, unless specified otherwise.• As is everything else, during construction the object is controlled by method; afterwards it’sexecution can be controlled through start(), setPriority(),... investigated with getPriority() and isAlive(). JDK 1.1 is supposed to implement interruptionsas wellRace Condition:When multiple threads try to access a same object can produce corrupt data if one thread "races in" too quicklybefore an operation that should be atomic has completed.What is Java Thread Scheduler?It is part of JVM that decides which thread should run at any given moment.Also decides to take thread out of the Run state.Order in which Runnable can be chosen by the scheduler to run is not gauranteedWait and NotifyBy using wait and notify a thread can give up its lock at an abritary point and the wait for anotherthread to give it back for continuationDeadlock — an OverviewDeadlock occurs when two threads are blocked, with each waiting for the other's lock. Neither can run untill the other give up its lock, so they'll sit there and wait forever.• Problem:Resource 1 and and resource 2 must be used exclusivelyProcess 1 holds resource 1 and is requestion resource 2Process 2 holds resource 2 and is requestion resource 111.24. Deadlock• Aset of processes is in a deadlock state when every process in the set is waiting for an eventthat can be caused by only another process in the set11.25. Necessary Conditions• Adeadlock can occur if the following four conditions hold— mutual exclusion: least one resource must be held in a non-sharable mode— hold and wait: there is a process that is holding a resource and is waiting to acquireanother that is currently being held by other processes— no preemption: resources can only be released voluntarily— circular wait: See intro exampleWith super keyword, super class method are called, then Base class cannot acccess private string of super class.//Regarding STringsString str= "Hello"str+="World."str will point to a new string in memory. concatenating string causes a new string to be instantiateda new string in memory is created from the concatenation of the original string and the string being added to it.byte = 8 bitsWhat is the differnence between an Error and an Exception?An Error "indicates serious problems that a reasonable application should not try to catch.An Exception "indicates conditions that a reasonable application might want to catch."40 = 0101000a<<bLeft shift =Shift the bits on left by number specified(b) and add (b) number of '0' bits on the right sideLEft shift actually multiply (a) by 2^b40<<1 = 1010000a>>bRight shift = shifts the bits on right by number specified(b) and add (b) number of '0' bits on the left sideits keeps the sighned bitRight shift actually multiply (a) by 2^b40>>1 =0010100a>>>bSigned right shift = shifts the bits on right by number specified(b) and add (b) number of '0' bits on the left side40>>>1 = 0101000Error & Exception : 1)java.lang.Error class represents the errors which are mainly caused by the run time environment in which application is running.  For example, OutOfMemoryError occurs when JVM runs out of memory or StackOverflowError occurs when stack overflows. 2)java.lang.Exception class represents the exceptions which are mainly caused by the application itself. 	-For example, NullPointerException occurs when an application tries to access null object or 	ClassCastException occurs when an application tries to cast incompatible class types.	-Java programs can also throw exceptions explicitly, using throw statement.		1)Recovering from Error is not possible. The only solution to errors is to terminate the execution.  2)Where as you can recover from Exception by using either try-catch blocks or throwing exception back to caller.break leaves a loop, continue jumps to the next iterationIt will simply do nothing and not enter in any case.What if we dont have default statement?It is recommended to have a default clause as the final clause in a switch statement. Programs like Lint will warn if you forget the default clause. It will simply do nothing and not enter in any case.//	And for information note that the default clause is required in MISRA-C.class methods v/s Instance methods(Non-static methods)1)Static Methods: A method that is declared static is called a class method. A class method is always invoked without reference to a particular object.2)An instance method is always invoked with respect to an object, which becomes the current object to which the keywords this and super refer during execution of the method body.Static field DefinitionA static field is a field only accessible by static methods. Static fields belongs to the class, not instances of the class. Thus, all instances will see the same field value. A non-static field value can be different for every object (instance of a class).static keyword:static means that the variable or method marked as such is available at the class level. In other words, you don't need to create an instance of the class to access it.	If two formal parameters are declared to have the same name (that is, their declrations mention the same identifier), then a compile-time error occurs.Protected methods and variables are accessible to subclasses and provide a way of opening up the encapsulation.Private methods and variables are not accessible to subclasses.A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have a constructor that takes no arguments.   Vector implements a dynamic array.  Like ArrayList it also maintains insertion order , but Vector is synchronized. new Vector() --> creates default size of 10. When 11th element is inserted, it size gets double Important methods of Vector Class:void addElement(Object element): It inserts the element at the end of the Vector.int capacity(): This method returns the current capacity of the vector.int size(): It returns the current size of the vector.void setSize(int size): It changes the existing size with the specified size.boolean contains(Object element): This method checks whether the specified element is present in the Vector. If the element is been found it returns true else false.boolean containsAll(Collection c): It returns true if all the elements of collection c are present in the Vector.Object elementAt(int index): It returns the element present at the specified location in Vector.Object firstElement(): It is used for getting the first element of the vector.Object lastElement(): Returns the last element of the array.Object get(int index): Returns the element at the specified index.boolean isEmpty(): This method returns true if Vector doesn’t have any element.boolean removeElement(Object element): Removes the specifed element from vector.boolean removeAll(Collection c): It Removes all those elements from vector which are present in the Collection c.void setElementAt(Object element, int index): It updates the element of specifed index with the given element.Collection.reverse(List) methodprivate List reverseList(List myList) {    List invertedList = new ArrayList();    for (int i = myList.size() - 1; i >= 0; i--) {        invertedList.add(myList.get(i));    }    return invertedList;}Observer & Observable1.) Observable is a Class and Observer is an Interface (interface has only one method "void update(Observable o, Object arg)" This(update()) method is called whenever the observed object is changed. An application calls an Observable object’s notifyObservers method to have all the object’s observers notified of the change.)2.) Observable class maintain a list of observers3.) When an Observable object is updated it invokes the update() method of each of its observers to notify that, it is changed//Twitter example. My Twiiter Account is Observer and celebrities you follow is the ObservableTwitter adds you to their(celebrities) follower list. When they sent a new tweet in, you see it in your input.import java.util.Observer;import java.util.Observable;public class TestObserved extends Observable {        public void abc(String name) {                 setChanged();    //Sets the internal flag that indicates this observable has changed state.                notifyObservers(name);          // 2  Checks the internal flag to see if the observable has changed state and notifies all observers.        }         public void def(Integer value) {                 setChanged();                 notifyObservers(value);         // 3  Checks the internal flag to see if the observable has changed state and notifies all observers.	        }         public static void main(String args[]) {                 TestObserved s = new TestObserved();                TheObserved  aTheObserved = new TheObserved();                                s.addObserver(aTheObserved);    // 1  Adds an observer to the internal list of observers.                s.abc("x");                s.def(1234);        }}public class TheObserved implements Observer {        public void update( Observable aObservable, Object o ) {  //Called when a change has occurred in the state of the observable.                if ( o instanceof String )      {                        System.out.println("String:update:o " + o );                } else {                        System.out.println("! String:update");                }        }}An object is serializable only if its class implements the Serializable interface. Thus, if you want to serialize the instances of one of your classes, the class must implement the Serializable interface. The good news is that Serializable is an empty interface. That is, it doesn’t contain any method declarations; it’s purpose is simply to identify classes whose objects are serializable.Thread1.interupt() //Interupts the threadif (Thread.interrupted())  // Clears interrupted status!      throw new InterruptedException();	  Interface methods can’t be native, static, synchronized, final, private, or protectedWhen an object is serialized, any object reference it contains are also serialized.What is an IntranetA local area network which may not be connected to the Internet, but which has some similar functions. Some organizations set up World Wide Web servers on their own internal networks so employees have access to the organization’s Web documentProtocol - a formal description of message formats and the rules that two or more machines must follow to exchange those messages."Protocols exist at every point where logical program flow crosses between hosts.In other words, we need protocols every time we want to do something on another computer.Protocol layering is a common technique to simplify network designs by dividing them into functional layers.There are two major layered protocol designs in use today.○ The DoD 4-Layer model (Department of Defense) [Application -- Transport -- Internet -- Network Access]○ The OSI 7-Layer model. (Open System Interconnections)[Application - Presentation - Session - Transport - Network - Data link - Physical]RMI:1. Create an interface that extends java.rmi.Remote.a. Every method in the interface must throw java.rmi.RemoteException2. Create an implementation of the interface that alsoextends UnicastRemoteObject3. Write a server that binds the implementation to a name inthe RMI registry.4. Write a client that uses the same name to create a proxy tothe remote object in the RMI registry.5. Run the application.a. Start the RMI registry.b. Start the server.c. Start the clienReflection API:The reflection API provides a mechanism for dynamically inspecting a class to discover details about the class.Get and set accessible fields.(Get and set the value of an object’s field, even if the field name is unknown to your program until runtime.)Create new instances of a class by invoking constructors.(Create an instance of a class whose name is not known until runtime.)Invoke methods.(nvoke a method on an object, even if the method is not known until runtime.)Create a new array, whose size and component type are not known until runtime, and then modify the array’s componentMaking use of external, user-defined objects in an application, e.g. Java Beans. Providing class browsers in visual development environments. Debuggers and test tools that can examine private members on classes, and use reflection to find and execute tests in a test suite.Its used as Debugger, As a test tools, class browsers,Determine class of an object, methods and constructor	Get information about a class’s modifiers, fields, methods, constructors, and superclasses.Class c = o.getClass();String s = c.getName();Creating Distributed Applications Using RMI1.Design and implement the components of your distributed application.2.Compile sources and generate stubs.  Compile as usual ... see makefile3.Make classes network accessible.In this step you make everything--the class files associated with the remote interfaces, stubs, and other classes that need to be downloaded to clients.4.Start the application.Starting the application includes running the RMI remote object registry, the server, and the client.These are the typical steps:1.Open a socket.2.Open an input stream and output stream to the socket.3.Read from and write to the stream according to the server’s protocol.4.Close the streams.5.Close the socket.