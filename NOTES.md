Time Complexity: describes the computational complexity of algorithms in terms of time taken to run as a function of the length of the input.

constant: O(1)
logarithmic: O(log n) - reduces the problem size by half each time
linear: O(n) - processes each element once
linearithmic: O(n log n) - combines linear and logarithmic
quadratic: O(n^2) - nested iterations over the data
exponential: O(2^n) - solutions that build on previous solutions
factorial: O(n!) - all permutations of the input

Space Complexity: describes the amount of memory space required by an algorithm as a function of the length of the input.

Problem Solving Process:
Read problem twice
Think different ways to approach the problem
think e2e of the best solutions based on complexity

Patterns:
Two Pointers
Sliding Window
Breadth-First Search
Depth-First Search
Backtracking
Heap
Binary Search

## Learning & Visualization Resources

### Existing Visual Tools:

1. **VisuAlgo** (https://visualgo.net/)

   - Interactive visualizations for algorithms
   - Covers sorting, graph algorithms, data structures
   - Step-by-step execution with animations

2. **Algorithm Visualizer** (https://algorithm-visualizer.org/)

   - Code execution with visual representation
   - Multiple programming languages
   - Community-contributed algorithms

3. **LeetCode Playground**

   - Built-in code testing
   - Some problems have visual explanations

4. **Pythontutor** (http://pythontutor.com/)
   - Step-through code execution
   - Memory visualization
   - Great for understanding data structures

### Custom Visualization Development Plan:

#### Phase 1: Basic Setup

- [ ] Create interactive Jupyter notebooks for each pattern
- [ ] Use matplotlib, plotly, or pygame for visualizations
- [ ] Implement step-by-step algorithm execution

#### Phase 2: Pattern-Specific Visualizers

- [ ] Two Pointers: Array visualization with moving pointers
- [ ] Sliding Window: Window movement animation
- [ ] BFS/DFS: Tree/graph traversal with color coding
- [ ] Backtracking: Decision tree exploration
- [ ] Heap: Tree structure with heapify operations
- [ ] Binary Search: Array division visualization

#### Phase 3: Practice Integration

- [ ] Problem-solving templates for each pattern
- [ ] Complexity analysis for each implementation
- [ ] Test cases with visual debugging

### Study Schedule (4-6 weeks):

**Week 1-2**: Two Pointers & Sliding Window
**Week 3**: BFS & DFS
**Week 4**: Backtracking & Binary Search  
**Week 5**: Heap & Advanced patterns
**Week 6**: Mock interviews & review
